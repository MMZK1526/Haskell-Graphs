# Haskell-Graphs
Implements graph-related algorithms in Haskell.  
Based on the Imperial College First-Year Course: 40008 Graphs and Algorithms. 
(Just starting, I'll add algorithms as the course goes on)  
For a quick guide on the algorithms, check out Example.hs.  

# Graph.hs
Implements graph using Adjacency List;  
Provides a type class for graphs.  

# Search
Implements Depth-First Search & Breadth-First Search;  
Generate spanning trees and computes depth of each node given the root;  
Checks connectivity of graphs;  
Computes distance between two nodes;
Conducts topological sort on directed acylic graphs (DAG).  

* `depthFirstNodes :: :: Graph a => Int -> a -> [(Int, Int)]`  
  * Traverses the graph using Depth-First Search from a given node and returns the list of passed nodes and their depths.  
  * Pre: The given node is in the graph.  
  * The polymorphic type 'a' represents the graph.  
  * Argument 1 (Int):  
    * The root node for the search.  
  * Argument 2 (Graph a => a):  
    * The graph.  
  * Result:  
    * A list of tuples, where for each entry the first element is the node, and the second element is the depth of the corresponding node.  

* `depthFirstTree :: Graph a => Int -> a -> a`  
  * Traverses the graph using Depth-First Search from a given node and returns the corresponding spanning tree.  
  * Pre: The given node is in the graph.  
  * The polymorphic type 'a' represents the graph.  
  * Argument 1 (Int):  
    * The root node for the search.  
  * Argument 2 (Graph a => a):  
    * The graph.  
  * Result:  
    * The spanning tree generated by the search.  

* `topologicalSort :: Graph a => a -> Maybe [Int]`  
  * Topological sorting of a directed acyclic graph (DAG).  
  * If the graph contains a cycle, will return Nothing.  
  * The polymorphic type 'a' represents the graph.  
  * Argument 1:  
    * The graph.  
  * Result:  
    * A topological ordering of the nodes of the graph, if exists, wrapped in a Just; if no such ordering exists, then Nothing.  

* `depthFirstS :: Graph a => Int -> a -> Bool -> (Int -> State (Maybe b) ()) -> (Int -> State (Maybe b) ()) -> State ((Set Int, Set Int), (Maybe b)) ()`  
  * A State that simulates Depth-First Search.  
  * This function is convoluted and is not necessary unless you need to do custom actions during the Depth-First Search.  
  * The polymorphic type 'a' represents the graph.  
  * The polymorphic type 'b' represents the information produced by the search, e.g. a spanning tree or a list of nodes in some specific order.  
  * Argument 1 (Int):
    * The root node for the search.
  * Argument 2 (Graph a => a):  
    * The graph.  
  * Argument 3 (Bool):  
    * If False, then the search will terminate when a cycle is encountered;  
    * If True, then the search will continue when a cycle is encountered.  
  * Argument 4 (Int -> State (Maybe b) ()):  
    * This function will be called whenever the search passes a new node  
    * for the FIRST time.  
    * Argument 1:  
      * The node that the search encounters for the first time.  
    * Result:   
      * A State that updates the information;  
      * If it is Nothing, then the search will terminate.  
  * Argument 5 (Int -> State (Maybe b) ()):  
    * This function will be called whenever the search passes a new node  
    * for the LAST time.  
    * Argument 1:
      * The node that the search encounters for the last time.  
    * Result:  
      * A State that updates the information;  
      * If it is Nothing, then the search will terminate.  
  * Result:  
    * A State that stores the tuple of firstly/lastly visited nodes (should be the same if the search is not prematurely terminated), as well as information produced by the search.  
