# Haskell-Graphs
Implements graph-related algorithms in Haskell.  
Based on the Imperial College First-Year Course: 40008 Graphs and Algorithms. 
(Just starting, I'll add algorithms as the course goes on)  
For a quick guide on the algorithms, check out Example.hs.  

# Graph.hs
Implements graph using Adjacency List;  
Provides a type class for graphs.  

# Search
Implements Depth-First Search & Breadth-First Search;  
Generates spanning trees and computes depth of each node given the root;  
Checks connectivity of graphs;  
Computes distance between two nodes;
Conducts topological sort on directed acylic graphs (DAG).  

* `depthFirstNodes :: :: Graph a => Int -> a -> [(Int, Int)]`  
  * Traverses the graph using Depth-First Search from a given node and returns the list of passed nodes and their depths.  
  * Pre: The given node is in the graph.  
  * The polymorphic type 'a' represents the graph.  
  * **Argument 1 (Int):**  
    * The root node for the search.  
  * **Argument 2 (Graph a => a):**  
    * The graph.  
  * **Result:**  
    * A list of tuples, where for each entry the first element is the node, and the second element is the depth of the corresponding node.  

* `depthFirstTree :: Graph a => Int -> a -> a`  
  * Traverses the graph using Depth-First Search from a given node and returns the corresponding spanning tree.  
  * Pre: The given node is in the graph.  
  * The polymorphic type 'a' represents the graph.  
  * **Argument 1 (Int):**  
    * The root node for the search.  
  * **Argument 2 (Graph a => a):**  
    * The graph.  
  * **Result:**  
    * The spanning tree generated by the search.  

* `topologicalSort :: Graph a => a -> Maybe [Int]`  
  * Topological sorting of a directed acyclic graph (DAG).  
  * If the graph contains a cycle, will return Nothing.  
  * The polymorphic type 'a' represents the graph.  
  * **Argument 1:**  
    * The graph.  
  * **Result:**  
    * A topological ordering of the nodes of the graph, if exists, wrapped in a Just; if no such ordering exists, then Nothing.  

* `breadthFirstNodes :: :: Graph a => Int -> a -> [(Int, Int)]`  
  * Traverses the graph using Breadth-First Search from a given node and returns the list of passed nodes and their depths.  
  * Pre: The given node is in the graph.  
  * The polymorphic type 'a' represents the graph.  
  * **Argument 1 (Int):**  
    * The root node for the search.  
  * **Argument 2 (Graph a => a):**  
    * The graph.  
  * **Result:**  
    * A list of tuples, where for each entry the first element is the node, and the second element is the depth of the corresponding node.  

* `breadthFirstTree :: Graph a => Int -> a -> a`  
  * Traverses the graph using Breadth-First Search from a given node and returns the corresponding spanning tree.  
  * Pre: The given node is in the graph.  
  * The polymorphic type 'a' represents the graph.  
  * **Argument 1 (Int):**  
    * The root node for the search.  
  * **Argument 2 (Graph a => a):**  
    * The graph.  
  * **Result:**  
    * The spanning tree generated by the search.  

* `isConnected :: Graph a => a -> Bool`  
  * Test if the graph is connected  
  * The polymorphic type 'a' represents the graph.  
  * **Argument 1:**
    * The graph.   
  * **Result:**  
    * True if the graph is connected (strongly connected if it is directed);
    * False if the graph is disconnected.  

* `distance :: Graph a => Int -> Int -> a -> Maybe Int`  
  * Returns the (unweighted) distance between two nodes;  
  * Pre: The given nodes are in the graph.  
  * The polymorphic type 'a' represents the graph.  
  * **Argument 1 (Int):**
    * The first node.  
  * **Argument 2 (Int):**
    * The second node.  
  * **Argument 3 (Graph a => a):**
    * The graph.   
  * **Result:**  
    * A non-negative Int representing the unweighted distance from the first node to the second node;  
    * If no such path exists, then Nothing.  

* `depthFirstS :: Graph a => Int -> a -> Bool -> (Int -> State (Maybe b) ()) -> (Int -> State (Maybe b) ()) -> State ((Set Int, Set Int), (Maybe b)) ()`  
  * A State that simulates Depth-First Search.  
  * This function is convoluted and is not necessary unless you need to do custom actions during the Depth-First Search.  
  * The polymorphic type 'a' represents the graph.  
  * The polymorphic type 'b' represents the information produced by the search, e.g. a spanning tree or a list of nodes in some specific order.  
  * **Argument 1 (Int):**  
    * The root node for the search.  
  * **Argument 2 (Graph a => a):**  
    * The graph.  
  * **Argument 3 (Bool):**  
    * If False, then the search will terminate when a cycle is encountered;  
    * If True, then the search will continue when a cycle is encountered;  
    * Note that here an undirected arc is considered as a cycle as well.  
  * **Argument 4 (Int -> State (Maybe b) ()):**  
    * This function will be called whenever the search passes a new node for the FIRST time.  
    * *Argument 1:*  
      * The node that the search encounters for the first time.  
    * *Result:*  
      * A State that updates the information;  
      * If it is Nothing, then the search will terminate.  
  * **Argument 5 (Int -> State (Maybe b) ()):**  
    * This function will be called whenever the search passes a new node for the LAST time.  
    * *Argument 1:*  
      * The node that the search encounters for the last time.  
    * *Result:*  
      * A State that updates the information;  
      * If it is Nothing, then the search will terminate.  
  * **Result:**  
    * A State that stores the tuple of firstly/lastly visited nodes (should be the same if the search is not prematurely terminated), as well as information produced by the search.  
  * Pre: The given node is in the graph.  

* `breadthFirstS :: Graph a => Int -> a -> (Int -> State (Maybe b) ()) -> (Int -> State (Maybe b) ()) -> State ((Set Int, Set Int), (Maybe b)) ()`  
  * A State that simulates Breadth-First Search.  
  * This function is convoluted and is not necessary unless you need to do custom actions during the Breadth-First Search.  
  * The polymorphic type 'a' represents the graph.  
  * The polymorphic type 'b' represents the information produced by the search, e.g. a spanning tree or a list of nodes in some specific order.  
  * **Argument 1 (Int):**  
    * The root node for the search.  
  * **Argument 2 (Graph a => a):**  
    * The graph.  
  * **Argument 3 (Int -> State (Maybe b) ()):**  
    * This function will be called whenever the search passes a new node for the FIRST time (when the node is added into the frontier).  
    * *Argument 1:*  
      * The node that the search encounters for the first time.  
    * *Result:*  
      * A State that updates the information;  
      * If it is Nothing, then the search will terminate.  
  * **Argument 4 (Int -> State (Maybe b) ()):**  
    * This function will be called whenever the search passes a new node for the LAST time (when the node is popped from the frontier).  
    * *Argument 1:*  
      * The node that the search encounters for the last time.  
    * *Result:*  
      * A State that updates the information;  
      * If it is Nothing, then the search will terminate.  
  * **Result:**  
    * A State that stores the tuple consists all visited nodes and the frontier (which should be empty if the search is not prematurely terminated), as well as information produced by the search.  
  * Pre: The given node is in the graph.  
